name: 'Full Stack CI/CD Pipeline' (disabled)

# Disabled: this full-stack pipeline duplicates other workflows (CI and deploy).
# Keep it for reference, but run it manually via the Actions UI if needed.
on:
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend

jobs:
  test:
    name: 'Run Tests'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install Python dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install pytest pytest-cov
        pip install -r app/requirements.txt

    - name: Run Python tests
      run: |
        cd backend/app
        python -m pytest test_main.py -v --cov=main

    - name: Install Node.js dependencies
      run: |
        cd frontend
        npm ci

    - name: Run Node.js tests
      run: |
        cd frontend
        npm test

  build-and-push:
    name: 'Build and Push Images'
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for backend
      id: backend-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract metadata for frontend
      id: frontend-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.backend-meta.outputs.tags }}
        labels: ${{ steps.backend-meta.outputs.labels }}

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ steps.frontend-meta.outputs.tags }}
        labels: ${{ steps.frontend-meta.outputs.labels }}

  terraform:
    name: 'Terraform Infrastructure'
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      id-token: write

    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Terraform Format
      run: terraform fmt -check

    - name: Terraform Init
      run: terraform init

    - name: Terraform Validate
      run: terraform validate

    - name: Terraform Plan
      run: terraform plan -input=false

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main'
      run: terraform apply -auto-approve -input=false

  deploy:
    name: 'Deploy Application'
    needs: [build-and-push, terraform]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Get EC2 instance details
      id: get-instance
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=fullstack-cicd-instance" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        INSTANCE_IP=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text)
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "instance-ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: Deploy to EC2
      env:
        INSTANCE_IP: ${{ steps.get-instance.outputs.instance-ip }}
        BACKEND_IMAGE: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:latest
        FRONTEND_IMAGE: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:latest
      run: |
        # Install SSH client
        sudo apt-get update && sudo apt-get install -y openssh-client

        # Add EC2 to known hosts
        ssh-keyscan -H $INSTANCE_IP >> ~/.ssh/known_hosts

        # Create SSH key from secret
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa

        # Copy deployment files to EC2
        scp -r ./deployment ubuntu@$INSTANCE_IP:/home/ubuntu/

        # Execute deployment script
        ssh ubuntu@$INSTANCE_IP << 'EOF'
          cd /home/ubuntu/deployment

          # Login to GitHub Container Registry
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # Pull latest images
          docker pull ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:latest
          docker pull ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:latest

          # Update docker-compose with new images
          export BACKEND_IMAGE=${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:latest
          export FRONTEND_IMAGE=${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:latest

          # Blue-Green deployment
          ./blue-green-deploy.sh
        EOF

    - name: Health Check
      run: |
        INSTANCE_IP=${{ steps.get-instance.outputs.instance-ip }}

        # Wait for deployment to complete
        sleep 30

        # Check application health
        for i in {1..5}; do
          if curl -f http://$INSTANCE_IP/health; then
            echo "\u2705 Application is healthy!"
            break
          else
            echo "\u23f3 Waiting for application to start... (attempt $i/5)"
            sleep 10
          fi
        done
